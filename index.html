<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Breakout</title>
  <script src="//cdn.jsdelivr.net/npm/phaser@3.50.0/dist/phaser.min.js"></script>

</head>
<body>
  <script type = "text/javascript" src="breakout.js" >
  </script>

<script>
  var config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade'
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
  };

  var game = new Phaser.Game(config);

  let ball;
  let ballVelocity = 0;
  let bottomBorder;
  let topBorder;
  let leftBorder;
  let rightBorder;
  let bottomPaddle;
  let paddleX;
  let paddleDir;
  let paddleVelocity = 350;
  let gameScore = 0;
  let wKey;
  let aKey;
  let dKey;
  let gameLives;
  let gameLivesText;
  let gameRunning = true;
  let startState = true;
  let aIsDown;
  let dIsDown;
  let wIsDown;
  let brickCount = 0;
  let brickArr = [];
  let endText;
  let paddleSound;
  let background;
  let brickSound;

  let level = [
    ['1','1','1','1','1','1','1','1','1','1'],
    [' ','2',' ','2',' ','2',' ','2',' ','2'],
    ['3','3','3','3','3','3','3','3','3','3'],
    [' ','2',' ','2',' ','2',' ','2',' ','2'],
    ['1','1','1','1','1','1','1','1','1','1']
  ]

  function preload ()
  {
    this.load.image('eye', 'assets/lance-overdose-loader-eye.png');
    this.load.image('ball', 'assets/58-Breakout-Tiles.png');
    this.load.image('background', 'assets/1624.jpg');
    this.load.image('paddle', 'assets/56-Breakout-Tiles.png');
    this.load.image('brick1', 'assets/07-Breakout-Tiles.png');
    this.load.image('brick2', 'assets/03-Breakout-Tiles.png');
    this.load.image('brick3', 'assets/01-Breakout-Tiles.png');
    this.load.audio('ballOnPaddle', 'sounds/pinging-noise.wav');
    this.load.audio('ballOnBrick', 'sounds/brick-crack.wav');
  }

  function create ()
  {
    background = this.add.sprite(0,0,'background').setScale(.45)
    paddleSound = this.sound.add('ballOnPaddle');
    brickSound = this.sound.add('ballOnBrick');

    const makeWall = (rect) => {
      this.physics.add.existing(rect, true)
      this.physics.add.collider(rect, ball)
      rect.visible = false;
    }

    const makePaddle = (rect) => {
      this.physics.add.existing(rect, false)
      this.physics.add.collider(ball, rect, function(x){moveBall()})
      rect.body.immovable = true;
      rect.body.setCollideWorldBounds(true);
      rect.body.setFriction(0)
    }

    const makeBricks = (rect, hitCount) => {
      this.physics.add.existing(rect, false)
      this.physics.add.collider(rect, ball, () => {
        if (hitCount === 1){
          brickCount-=1;
          rect.destroy()
          brickSound.play();
        } else {
          hitCount-=1;
          rect.setTexture(`brick${hitCount}`);
          // rect = makeBricks((this.physics.add.sprite(((col * brickWidth) + brickWidth / 2), ((row * brickHeight) + brickHeight / 2) + 100, `brick${hitCount}`)).setScale(.2), hitCount)
          brickSound.play();
        }

      })
      rect.body.immovable = true;
      rect.body.onCollide = true;
      brickArr.push(rect)
    }

    ball = this.physics.add.sprite(400, 300, 'ball').setInteractive().setVelocity(0,ballVelocity).setBounce(1,1).setScale(.2);
    topBorder = this.add.rectangle(this.cameras.main.centerX, 0, this.cameras.main.centerX * 2, 10, 0xFF0000)
    leftBorder = this.add.rectangle(0, this.cameras.main.centerY, 10, this.cameras.main.centerX * 2, 0xFF0000)
    rightBorder = this.add.rectangle(this.cameras.main.centerX * 2, this.cameras.main.centerY, 10, this.cameras.main.centerX * 2, 0xFF0000)

    let walls = [topBorder, leftBorder, rightBorder]
    walls.map(makeWall)

    paddleX = this.cameras.main.centerX;
    bottomPaddle = this.physics.add.sprite(this.cameras.main.centerX, 550, 'paddle').setScale(.15)
    let paddles = [bottomPaddle]
    paddles.map(makePaddle)

    wKey = this.input.keyboard.addKey('W');
    aKey = this.input.keyboard.addKey('A');
    dKey = this.input.keyboard.addKey('D');


    for (row=0; row<level.length; row++) {
      for (col=0; col<level[row].length; col++) {
        let brickWidth = ((this.cameras.main.centerX * 2) / level[row].length);
        let brickHeight = 28;

        let current = level[row][col];
        if (current === '1'){
          brickCount+=1;
          makeBricks((this.physics.add.sprite(((col * brickWidth) + brickWidth / 2), ((row * brickHeight) + brickHeight / 2) + 100, 'brick1')).setScale(.2), 1);
        }
        if (current === '2'){
          brickCount+=1;
          makeBricks((this.physics.add.sprite(((col * brickWidth) + brickWidth / 2), ((row * brickHeight) + brickHeight / 2) + 100, 'brick2')).setScale(.2), 2);
        }
        if (current === '3'){
          brickCount+=1;
          makeBricks((this.physics.add.sprite(((col * brickWidth) + brickWidth / 2), ((row * brickHeight) + brickHeight / 2) + 100, 'brick3')).setScale(.2), 3);
        }
      }
    }

    this.add.text((this.cameras.main.centerX * 2) - 100, (this.cameras.main.centerY * 2) - 50, `Score:   ${gameScore}`, { fontFamily: 'Georgia, "Goudy Bookletter 1911", Times, serif' }).setFontSize(20);

    gameLives = 3;
    gameLivesText = this.add.text((this.cameras.main.centerX * 2) - 100, (this.cameras.main.centerY * 2) - 100, `Lives:   ${gameLives}`, { fontFamily: 'Georgia, "Goudy Bookletter 1911", Times, serif' }).setFontSize(20);

    document.addEventListener('keydown', (keyEvent) => {
      if (keyEvent.key === 'a'){
        aIsDown = true;
      }
      if (keyEvent.key === 'd'){
        dIsDown = true;
      }
      if (keyEvent.key === 'w'){
        wIsDown = true;
      }
    })
    document.addEventListener('keyup', (keyEvent) => {
      if (keyEvent.key === 'a'){
        aIsDown = false;
      }
      if (keyEvent.key === 'd'){
        dIsDown = false;
      }
      if (keyEvent.key === 'w'){
        wIsDown = false;
      }
    })

    endText = this.add.text(this.cameras.main.centerX , this.cameras.main.centerY, ``, { fontFamily: 'Georgia, "Goudy Bookletter 1911", Times, serif' }).setFontSize(50)
    endText.visible = false;
  
  }

  function update() 
  {
    if (brickCount === 0){
      gameOver('win')
    }

    if (startState === true) {
      ball.visible = true;
      ball.setPosition(bottomPaddle.x, bottomPaddle.y - 50)
    }

    if (ball.y > this.cameras.main.centerY * 2) {
      console.log("Off screen");
      gameLives-=1;

      if (gameLives === 0){
        gameOver('loss')
      }

      ball.visible = false;
      ball.setPosition(400, 300)
      gameLivesText.setText(`Lives:   ${gameLives}`).setFontSize(20);
      ballVelocity = 0;
      ball.setVelocity(0,ballVelocity)
      startState = true;
    }

    if (startState === true && wIsDown) {
      startState = false;
      ballVelocity = 300;
      // ball.setVelocity(0,-ballVelocity)
      moveBall()
    }
    if (aIsDown) {
      movePaddle(bottomPaddle, 'left')
    }
    if (dIsDown) {
      movePaddle(bottomPaddle, 'right')
    }
    if ((!aIsDown && !dIsDown) || (aIsDown && dIsDown)) {
      movePaddle(bottomPaddle, 'stop')
    }

  }

  function movePaddle(paddle, dir) {
    paddleDir = dir;
    if (dir === 'left') {
      paddle.body.setVelocityX(-paddleVelocity)
    } else if (dir === 'right') {
      paddle.body.setVelocityX(paddleVelocity)
    } else if (dir === 'stop') {
      paddle.body.setVelocityX(0)
    }
  }

  function moveBall(){
    console.log(paddleDir);
    if (paddleDir === 'left'){
      ball.body.setVelocity(-ballVelocity,-ballVelocity)
    } else if (paddleDir === 'right'){
      ball.body.setVelocity(ballVelocity,-ballVelocity)
    } else if (paddleDir === 'stop'){
      ball.body.setVelocity(0,-ballVelocity)
    }
    paddleSound.play({volume: .3});
  }

  function gameOver(status){
    gameRunning = false;
    ball.visible = false;
    brickArr.map(brick => brick.visible = false);
    if (status === 'win'){
      endText.visible = true;
      endText.setText('You won!')
    }
    if (status === 'loss'){
      endText.visible = true;
      endText.setText('You lost!')
    }
    // console.log(`In gameOver --> ${status}`)
  }


  // TODO: 
  // Ball should be able to break two bricks at once
  // If paddle is moving when ball is launched, shoot it that direction
  // Position endText based on width and height

</script>



</body>
</html>